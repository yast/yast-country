/**
 * File:	modules/Timezone.ycp
 * Package:	Country settings
 * Summary:	Timezone related stuff
 * Authors:	Klaus Kaempf <kkaempf@suse.de>
 *		Thomas Roelz <tom@suse.de>
 *
 * $Id$
 */

{

module "Timezone";
textdomain "country";

import "Arch";
import "Language";
import "Misc";
import "Mode";
import "Storage";
import "String";

// --------------------------------------------------------------
// START: Globally defined data to be accessed via Timezone::<variable>
// --------------------------------------------------------------

global string timezone = "";	// e.g. "Europe/Berlin"

// hwclock parameter
// possible values:
//	 ""		dont change timezone
//	 "-u"		system clock runs UTC
//   "--localtime"	system clock runs localtime
global string hwclock = "";

// The default timezone if set.
//
global string default_timezone = "";

// Flag indicating if the user has chosen a timezone.
// To be set from outside.
//
global boolean user_decision = false;
global boolean user_hwclock = false;

global integer diff = 0;

map push = $[];

// ------------------------------------------------------------------
// END: Globally defined data to be accessed via Timezone::<variable>
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// START: Locally defined data
// ------------------------------------------------------------------

string name = "";

list zonemap = [];
map lang2tz = $[];

// ------------------------------------------------------------------
// END: Locally defined data
// ------------------------------------------------------------------


// ---------------------------------------------------------------------------------------
// START: Globally defined functions
// ---------------------------------------------------------------------------------------

/*
 * get_lang2tz()
 *
 * Get the language --> timezone conversion map.
 *
 * @param	-
 *
 * @return  conversion map
 *
 * @see	get_zonemap()
 */

define map get_lang2tz()
    ``{
    // language --> timezone database, e.g. "de_DE" : "Europe/Berlin"
    //
    if( size(lang2tz)==0 )
	{
	lang2tz = (map)SCR::Read( .target.yast2, "lang2tz.ycp" );
	if( lang2tz == nil ) lang2tz = $[];
	}
    return( lang2tz );
    }	// get_lang2tz()

/*
 * get_zonemap()
 *
 * Get the timezone database.
 *
 * @param	-
 *
 * @return  timezone DB (map)
 *
 * @see	get_lang2tz()
 */

define list get_zonemap()
    ``{
    if( size(zonemap)==0 )
	{
	zonemap = (list)eval(SCR::Read( .target.yast2, "timezone_raw.ycp" ));
	if( zonemap == nil ) zonemap = [];
	}
    return( zonemap );
    }	// get_zonemap()

// ------------------------------------------------------------------
// END: Locally defined functions
// ------------------------------------------------------------------
/**
 * Set()
 *
 * Set system to selected timezone.
 *
 * @param	string timezone to select, e.g. "Europe/Berlin"
 *
 * @return	the number of the region that contains the timezone
 *
 */
global define integer Set( string zone, boolean really )
    ``{
    list zmap = get_zonemap();

    // Set the new timezone internally
    timezone = zone;

    integer sel = 0;
    while( sel<size(zmap) && !haskey(zmap[sel,"entries"]:$[], zone) )
	{
	sel = sel + 1;
	}

    textdomain "timezone_db";
    locale translate =  zmap[sel,"name"]:"";
    name = (string)eval(translate);
    name = name + " / ";
    translate = zmap[sel,"entries",timezone]:zone;
    name = name + (string)eval(translate);
    textdomain "country";

    // Adjust system to the new timezone.
    //
    if( !Mode::config && really )
	{
	SCR::Execute( .target.bash, "/usr/sbin/zic -l " + timezone );
	if( !Arch::s390 )
	    {
	    SCR::Execute(.target.bash, "/sbin/hwclock --hctosys " + hwclock);
	    }
	}
    
    // On first assignment store default timezone.
    //
    if( default_timezone == "" )	// not yet assigned
	{
	default_timezone = timezone;
	y2milestone( "Set default timezone: <%1>", timezone );
	}

    y2milestone( "Set timezone:%1 sel:%2 name:%3", timezone, sel, name );

    return( sel );
    }

/**
  * Timezone()
  *
  * The module constructor.
  * Sets the proprietary module data defined globally for public access.
  * This is done only once (and automatically) when the module is loaded for the first time.
  * Calls Set() in initial mode.
  * Reads current timezone from sysconfig in normal mode.
  *
  * @param	-
  *
  * @return  -
  *
  * @see	Set()
  */
global define void Timezone()
    ``{
    // Set default values.
    //
    hwclock = "-u";

    if( Mode::initial )
	{
	// language --> timezone database, e.g. "de_DE" : "Europe/Berlin"
	map lang2tz = get_lang2tz();

	string new_timezone = lang2tz[Language::language]:"";
	y2milestone( "new_timezone %1", new_timezone );

	if( new_timezone != "" )
	    {
	    Set( new_timezone, true );
	    }
	}
    else if( !Mode::config )
	{
	timezone = Misc::SysconfigRead(.sysconfig.clock.TIMEZONE, timezone );
	default_timezone = 
	    Misc::SysconfigRead(.sysconfig.clock.DEFAULT_TIMEZONE, 
	                        default_timezone);
	hwclock = Misc::SysconfigRead(.sysconfig.clock.HWCLOCK, hwclock);
	}
    return;
    }


global define void SetTime( string year, string month, string day, 
                            string hour, string minute, string second )
    ``{
    if ( !Arch::s390 )
	{
	string date = sformat( " --date=\"%1/%2/%3 %4:%5:%6\" ", month, day, 
	                       year, hour, minute, second );
	SCR::Execute(.target.bash, "/sbin/hwclock --set " + hwclock + date);
	SCR::Execute(.target.bash, "/sbin/hwclock --hctosys " + hwclock );
	}
    };

global define void PushVal()
    ``{
    push = $[ "hwclock" : hwclock, "timezone" : timezone ];
    y2milestone( "map %1", push );
    }

global define void PopVal()
    ``{
    y2milestone( "timezone %1 hwclock %2", timezone, hwclock );
    if( haskey( push, "hwclock" ))
	hwclock = push["hwclock"]:hwclock;
    if( haskey( push, "timezone" ))
	timezone = push["timezone"]:timezone;
    push = $[];
    y2milestone( "timezone %1 hwclock %2", timezone, hwclock );
    }

/**
 * GetTimezoneForLanguage()
 *
 * Get the timezone for the given system language.
 *
 * @param	System language code, e.g. "en_US".
 *		Default timezone to be returned if nothing found.
 *
 * @return  The timezone for this language, e.g. "english-us"
 *		or the default value if nothing found.
 *
 * @see	-
 */
global define string GetTimezoneForLanguage( string sys_language, 
                                             string default_language )
    ``{
    // The system_language --> timezone conversion map.
    //
    map lang2timezone = get_lang2tz();

    string ret = lang2timezone[sys_language]:"";
    if( size(ret)==0 )
	{
	ret = lang2timezone[default_language]:"US/Pacific";
	}
    y2milestone( "sys %1 def %2 ret %3", sys_language, default_language, ret );
    return ret;
    }



/**
 * GetDateTime()
 *
 * Get the output of /bin/date "+%H:%M:%S - %Y-%m-%d"
 *
 * @param	flag if to get real system time or if to simulate changed
 *		timezone settings with TZ=
 *
 * @return  The string output.
 *
 * @see	-
 */
global define string GetDateTime( boolean real_time )
    ``{
    string cmd = "";
    string date_format = "+%H:%M:%S - %d-%m-%Y";
    y2milestone( "hwclock %1", hwclock );
    if( !real_time )
	{
	integer ds = 0;
	string tzs = sformat( "TZ=%1 ", timezone );
	if( diff!=0 )
	    {
	    integer t = 0;
	    string tzd = 
		lookup( (map)SCR::Execute( .target.bash_output, 
				      sformat( "TZ=%1 date \"+%%z\"", timezone )),
			"stdout", "" );
	    y2milestone( "tcd=%1", tzd );
	    t = tointeger( String::CutZeros( substring( tzd, 1, 2 )));
	    ds = ds + t * 3600;
	    t = tointeger( String::CutZeros( substring( tzd, 3, 2 )));
	    ds = ds + t * 60;
	    if( substring( tzd, 0, 1 )=="-" )
		{
		ds = -ds;
		}
	    ds = ds;
	    y2milestone( "ds %1 diff %2", ds, diff );
	    }
	cmd = sformat( "TZ=%1 /bin/date \"%2\" \"--date=now %3sec\"", timezone,
	               date_format, ds*diff );
	}
    else
	{
	cmd = sformat( "/bin/date \"%1\"", date_format );
	}
    y2milestone( "cmd=%1", cmd );
    string local_date = lookup( (map)SCR::Execute( .target.bash_output, cmd ),
				"stdout", "" );
	
    // cut off LF
    //
    local_date = substring( local_date, 0 , size( local_date ) - 1 );

    return( local_date );
    }

/**
 * MakeProposal()
 *
 * Return proposal string and set system timezone.
 *
 * @param	boolean force_reset
 *		boolean language_changed
 *
 * @return	string	user readable description.
 *		If force_reset is true reset the module to the timezone
 *		stored in default_timezone.
 */

global define string MakeProposal( boolean force_reset, 
                                   boolean language_changed )
    ``{
    y2milestone( "force_reset: %1", force_reset );
    y2milestone( "language_changed: %1 user_decision %2 user_hwclock %3", 
                 language_changed, user_decision, user_hwclock );

    if( !user_hwclock || force_reset )
	{
	hwclock = "-u";
	if( size(Storage::GetWinPrimPartitions(Storage::GetTargetMap())) > 0 ||
	    Arch::board_mac )
	    {
	    // Win partitions present ==> assume local time.
	    //
	    hwclock = "--localtime";
	    y2milestone("Assuming local time");
	    }
	}
    if( force_reset )
	{
	// If user wants to reset do it if a default is available.
	//
	if( default_timezone != "" )
	    {
	    Set( default_timezone, true );	// reset
	    }

	// Reset user_decision flag.
	//
	user_decision = false;
	}
    else	// no reset
	{
	// Only follow the language if the user has never actively chosen
	// a timezone. The indicator for this is user_decision which is
	// set from outside the module.
	//
	if( user_decision || Mode::autoinst)
	    {
	    if( language_changed )
		{
		y2milestone("User has chosen a timezone; not following language - only retranslation.");

		Set( timezone, true );
		}
	    }
	else
	    {
	    // User has not yet chosen a timezone ==> follow language.
	    //
	    string local_timezone = 
		GetTimezoneForLanguage( Language::language, "english-us" );

	    if( local_timezone != "" )
		{
		Set( local_timezone, true );
		default_timezone = local_timezone;
		}
	    else
		{
		if( language_changed )
		    {
		    y2error("Can't follow language - only retranslation");

		    Set( timezone, true );
		    }
		}
	    }
	}

    // Clock setting: Abbreviation for Greenwhich mean time
    //

    // label text
    string clock_setting = _("UTC");

    // label text, Clock setting: local time (not UTC)
    if ( hwclock == "--localtime" ) clock_setting = _("local time");

    // label text
    string add_text = deletechars( _("&Hardware clock set to"), "&" );

    clock_setting = deletechars(add_text,":") + " " + clock_setting;

    string date = GetDateTime(true);

    y2milestone( "hwclock %1", hwclock );

    return( name + " - " + clock_setting + " " + date );
    }

/**
  * Selection()
  *
  * Return a map of ids and names to build up a selection list
  * for the user. The key is used later in the Set function
  * to select this timezone. The name is a translated string.
  *
  * @param	-
  *
  * @return	map	map for timezones 
  *			'timezone_id' is used internally in Set and Probe
  *			functions. 'timezone_name' is a user-readable string.
  *			Uses Language::language for translation.
  * @see Set()
  */

global define list Selection( integer num )
    ``{
    string trans_str = "";
    locale translate = "";
    list zmap = get_zonemap();

    textdomain "timezone_db";
    list trl = maplist( string key, locale name, zmap[num,"entries"]:$[],
		       ``{
		       translate = name;
		       return [ name, key ];
		       });
    textdomain "country";

    trl = sort( list a, list b, trl, 
                ``(select( lsort( [a[0]:"", b[0]:""] ), 0, "" ) == a[0]:"" ) && a!=b );
    y2milestone( "trl = %1", trl );

    list ret = maplist( list e, trl,
	``{
	return( `item( `id(e[1]:""), e[0]:"", false ));
	});
    return( ret );
    }

global define list Region()
    ``{
    list zmap = get_zonemap();
    string trans_str = "";
    locale translate = "";

    textdomain "timezone_db";
    integer num = -1;
    list ret = maplist( map entry, zmap,
	``{
	translate = entry["name"]:"";
	trans_str = (string)eval(translate);
	num = num + 1;
	return( `item( `id(num), trans_str, false ));
	});
    textdomain "country";
    return( ret );
    }


/**
 * Save()
 *
 * Save timezone to target sysconfig.
 *
 * @param	-
 *
 * @return	-
 */
global define void Save()
    ``{
    if ( Mode::update )
    {
	return;
    }

    SCR::Write(.sysconfig.clock.TIMEZONE, timezone);
    SCR::Write(.sysconfig.clock.DEFAULT_TIMEZONE, default_timezone);
    SCR::Write(.sysconfig.clock.HWCLOCK, hwclock);

    SCR::Write(.sysconfig.clock, nil);	// flush

    y2milestone( "Saved data for timezone: <%1>", timezone );

    return;
    }

global define map GetDateTimeMap()
    ``{
    map ret = $[];
    list dparts = filter( string v, splitstring( GetDateTime(true), " -:" ), 
                          ``(size(v)>0));
    ret["hour"] = dparts[0]:"";
    ret["minute"] = dparts[1]:"";
    ret["second"] = dparts[2]:"";
    ret["day"] = dparts[3]:"";
    ret["month"] = dparts[4]:"";
    ret["year"] = dparts[5]:"";
    y2milestone( "dparts %1 ret %2", dparts, ret );
    return( ret );
    }

global define boolean CheckTime( string hour, string minute, string second )
    ``{
    boolean ret = true;
    integer tmp = tointeger( String::CutZeros(hour) );
    ret = ret && tmp>=0 && tmp<24;
    tmp = tointeger( String::CutZeros(minute) );
    ret = ret && tmp>=0 && tmp<60;
    tmp = tointeger( String::CutZeros(second) );
    ret = ret && tmp>=0 && tmp<60;
    return( ret );
    }

global define boolean CheckDate( string day, string month, string year )
    ``{
    list mdays = [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];
    boolean ret = true;
    integer yea = tointeger(  String::CutZeros(year) );
    y2milestone( "xxx %1 %2", month, String::CutZeros(month) );
    integer mon = tointeger(  String::CutZeros(month) );
    ret = ret && mon>=1 && mon<=12;
    if( yea%4==0 && (yea%100!=0 || yea%400==0))
	{
	mdays[1] = 29;
	}
    integer da = tointeger(  String::CutZeros(day) );
    ret = ret && da>=1 && da<=mdays[mon-1]:0;
    ret = ret && yea>=1970 && yea<2032;
    return( ret );
    }

// ------------------------------------------------------------------
// END: Globally defined functions
// ------------------------------------------------------------------



}

// -EOF-
